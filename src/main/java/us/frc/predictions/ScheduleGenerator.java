package us.frc.predictions;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;

public class ScheduleGenerator {
  private static final String SCHEDULE_PATH = "data" + File.separator + "schedules";

  /**
   * Retrieves the random schedule for the input parameters from a file.  If that file
   * doesn't exist, this method will call MatchMaker to generate a new schedule.  The result
   * String[] array contains 1 match per element.  Each String in the array is a set of 6 numbers,
   * each separated by a space.  The numbers range from {1, pNumTeams} (inclusive).<br>
   * <br>
   * To use the schedule, use the numbers produced by this method to index into (e.g.) an ArrayList
   * that contains actual team numbers.  To generate a new "random" schedule, call Collections.shuffle()
   * on the team list, rather than creating a new random schedule from MatchMaker.
   * 
   * @param pNumTeams - number of teams at the event
   * @param pNumMatchesPerTeam - number of matches each team plays at the event
   */
  public static String[] getScheduleForTeams(int pNumTeams, int pNumMatchesPerTeam) {
    String[] result = null;
    
    if(result == null) {
      try {
        result = loadScheduleFromFile(pNumTeams, pNumMatchesPerTeam);
      } catch (Exception e) {
        // Don't care here - it will generate a new schedule if we couldn't read a file
      }
    }
    
    if(result == null) {
      try {
        System.out.println("Generating random schedule from MatchMaker, be patient...");
        generateScheduleFromMatchMaker(pNumTeams, pNumMatchesPerTeam);
        result = loadScheduleFromFile(pNumTeams, pNumMatchesPerTeam);
      } catch (Exception e) {
        e.printStackTrace();
        System.exit(-1);
      }
    }
    
    if(result == null) {
      System.err.println("Unable to find a schedule...");
      System.exit(-1);
    } else {
      System.out.println("Finished retrieving randomized schedule");
    }
    
    return result;
  }
  
  /**
   * Standardizes file names for schedule files
   */
  private static String generateFileName(int pNumTeams, int pNumMatchesPerTeam) {
    return "Schedule-" + pNumTeams + "-" + pNumMatchesPerTeam + ".txt";
  }
  private static String generateResourceName(int pNumTeams, int pNumMatchesPerTeam) {
    return SCHEDULE_PATH + File.separator + generateFileName(pNumTeams, pNumMatchesPerTeam);
  }
  
  /**
   * Self-explanatory.  Order shouldn't matter.  Returns null if there were errors.
   * @throws IOException if there was a problem reading the file
   */
  private static String[] loadScheduleFromFile(int pNumTeams, int pNumMatchesPerTeam) throws IOException {
    // TODO -implement way to read file from fully-self-contained jar
//    ScheduleGenerator.class.getResource(generateResourceName(pNumTeams, pNumMatchesPerTeam));
    
    String file = generateFileName(pNumTeams, pNumMatchesPerTeam);
    File f = new File(SCHEDULE_PATH, file);
    // We don't really care about order since simulating match 2 before match 1 nets the same
    // result as 1 before 2.
    List<String> lines = new ArrayList<>();
    lines.addAll(Files.readAllLines(f.toPath()));  // duplicate arrays mean we don't have to deal with null?
    return lines.toArray(new String[0]);
  }
  
  /**
   * Runs MatchMaker.exe -t <num teams> -r <num matches> -b -s -u 3
   * And dumps the results to a file.  Filename is generated by generateFileName() method.
   * 
   * @param pNumTeams 't' parameter for MatchMaker.exe
   * @param pNumMatchesPerTeam 'r' parameter for MatchMaker.exe
   * @throws IOException if there was a problem executing the external process
   */
  private static void generateScheduleFromMatchMaker(int pNumTeams, int pNumMatchesPerTeam) throws IOException, InterruptedException {
    String file = generateFileName(pNumTeams, pNumMatchesPerTeam);
    String exec = "ext-exec/MatchMaker.exe -t " + pNumTeams + " -r " + pNumMatchesPerTeam + " -b -s -u 3";
    
    
    System.out.println("Running " + exec);

    Runtime rt = Runtime.getRuntime();
    Process pr = rt.exec(exec);
  
    BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));
    List<String> lines = new ArrayList<>();
    String line;
    while ((line = in.readLine()) != null) {
      line = line
        .replaceAll(" 0", "")
        .replaceFirst("[0-9]{1,3} ", "")
        .trim()
        ;
      if(!"".equals(line)) { 
    //    System.out.println(line);
        lines.add(line);
      }
    }
    pr.waitFor();
    in.close();
    
    File outFile = new File(SCHEDULE_PATH, file);
    outFile.createNewFile();
    
    Files.write(outFile.toPath(), lines, StandardOpenOption.CREATE);
  }

  public static void main(String[] pArgs) throws Exception {
    int start = 241;
    int end = 100;
    
    for(int t = start ; t <= end; t++) {
      for(int m = 7; m <= 12; m++) {
        File file = new File(SCHEDULE_PATH, generateFileName(t, m));
        if(!file.exists()) {
          long s = System.currentTimeMillis();
          generateScheduleFromMatchMaker(t, m);
          System.out.println("Took " + (System.currentTimeMillis()-s)/1000 + " seconds");
        }
      }
    }
  }
}
